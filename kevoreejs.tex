\section{KevoreeJS: A runtime for reconfigurable single page applications in the browser}

This section present a module system for the Browser called KevoreeJS . 
%\ff{Just matter of presention, but i think we not target JS, we target the brower USING javascript. But the goal is really to target a usage and not a language no ? The language is a way todo.}
In particular, KevoreeJS implements a dynamic component model for SPA. 
This component model currently addresses only a part of the challenges discusses in Section 2.   

\subsection{Motivating Scenarios }
To illustrate the framework, we consider a simple dashboard for sensor-based system in which, it is required to install/uninstall a new web widget when a new sensor appears/disappears. In such system, three kinds of reconfiguration has to be managed: i) the installation and retrieval of software package (javascript code), the instantiation of components, the components parametrization (to bind components through ports, the setup of parameters, ...), the component life-cycle management. ii)  the client/server code partitioning to select if some components that manage complex event queries must be executed on the server side or within the browser. iii) the selection of a specific  deploy unit depending on the browser type, its devices and its screen layout. A figure of the results of such an application is presented in Figure\ref{fig:fig1}.   This dashboard provides information regarding values that can come from a set of nodes such as the one described in Figure~\ref{fig:fig2}


\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{figures/fig3}
	\caption{An example of dashboard for sensor-based applications}
	\label{fig:fig1}
\end{figure}


\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth]{figures/fig4}
	\caption{An example of sensor node based on Intel Edison}
	\label{fig:fig2}
\end{figure}


\subsection{KevoreeJS overview }
KevoreeJS is built on top of models@runtime paradigm. Models@runtime denotes model-driven approaches aiming at taming the complexity of dynamic adaptation. It basically pushes the idea of reflection~\cite{DBLP:conf/icse/MorinBNJ09} one step further by considering the reflection layer as a real model that can be used to drive the system deployment and (re) configuration: ``something simpler, safer or cheaper than reality to avoid the complexity, danger and irreversibility of reality''. In practice, component-based (and/or service-based) platforms like Fractal~\cite{bruneton2006fractal}, OpenCOM~\cite{grace2005reflective} or OSGi~\cite{hall2011osgi} offer reflection APIs which make it possible to introspect the system (which components and bindings are currently in place in the system) and dynamic adaptation (by applying CRUD operations on these components and bindings). While some of these platforms offer rollback mechanisms~\cite{david2006safe} to recover after an erroneous adaptation, the idea of models@runtime is to prevent the system from actually enacting an erroneous adaptation. In other words, the ``model at runtime'' is a reflection model which can be uncoupled (for reasoning, validation, simulation purposes) and automatically resynchronized. This modelling layer provides a common abstraction to describe the system configuration. this model can be interpreted to decide which packages (component package and third parties libraries) must be installed or removed and which component must be instantiated and started. This modelling layer can be also modified and push to peers to trigger distributed reconfigurations. 

KevoreeJS\footnote{http://runjs.kevoree.org}  implements the Kevoree component model. Kevoree is a dynamic component-based framework for distributed systems that follows the models@runtime paradigm and embeds a structural model of the distributed system. This model is used for two main purposes: (i) it represents a snapshot of the heterogeneous and distributed application state and (ii) it provides a language to drive the reconfiguration of this application. The Kevoree model embodies the following four main concepts of a distributed system. 

\begin{enumerate}
	\item The software \textbf{components} represent software units that provide the business value of the distributed system. 
\item The \textbf{connectors} (called channels in Kevoree) are in charge of inter-component communication. A channel encapsulates and provides a particular communication semantic (e.g. synchronous or asynchronous, unicast or multicast, and may provide different contracts for synchronization and quality of services). 
\item The \textbf{nodes} represent execution hosts for all other software entities such as components and channels. A node may represent a physical node or a virtual machine. Nodes are application containers and they are in charge of the dynamic adaptation of its system part when a new model@runtime is received. 
\item The \textbf{groups} are responsible for inter-node communication. In particular, a group provides semantics of dissemination and ensures consistency of models among nodes. On top of these abstractions, Kevoree provides a development model to design new components, channels, groups and containers using different programming languages. It also comes with a set of tools for building dynamic applications (a graphical editor to visualize and edit configurations, a textual language to express reconfigurations, several checkers to validate configurations). Kevoree supports multiple execution platforms (e.g., Java, Android, LXC, Docker, FreeBSD, Arduino). For each target platform it provides a specific runtime container as a specific node type. 

\end{enumerate}


For supporting the SPA within the browser, we mainly reuse the core of Kevoree component model which is written in Kotlin. This core contains the component model entities, tooling for loading and saving configuration models, tooling for detecting abstract actions (install a library, instantiate a component, bind a component to a channel, â€¦)  and tooling to achieve runtime adaptations when the platforms receive a new configuration model. As Kotlin provides code generators for JavaScript, we can reuse this core tool directly. As a consequence, to create KevoreeJS we mainly provide the concrete implementations of abstract actions in order to achieve concrete tasks within a running Browser core. We also provide a basic UI composition mechanism based on mashup. Each component comes with its own view that can be composed on the full SPA using mashup. To enable this mashup mechanism, we reuse framework such as AngularJS and angular-gridster. KevoreeJS reuses bower for its static Web part, but it handles the dynamicity by downloading browserified\footnote{http://browserify.org/} modules directly from the npm registry. 


Finally we provide a simple development model in JavaScript and in TypeScript for developing component, channel or  group. This development model are available online\footnote{ https://github.com/HEADS-project/training/tree/master/2.Kevoree\_Basics}, \footnote{https://github.com/kevoree/kevoree-js.d.ts }.  

KevoreeJS comes with a set of tools: a web-based architecture model editor, a Yeoman generator, a set of Grunt tasks to fully automate the component packaging and publishing and a container to manage the dynamic deployment of third-party libraries. 

\subsection{Evaluation} 
To validate the proposed approach, we mainly follow two ways. First we provide some figures on KevoreeJS in terms of line of code, number of reusable component available online, time penalty to load initiate KevoreeJS when loading the pages. Next, we evaluate the approach regarding the challenges discussed in Section 2. 

\subsubsection{Quantitative evaluation}
To implement the KevoreeJS core and the sensor based dashboard, we create 8 components, 3 channels, 3 groups. The core of KevoreeJS and these 14 software artefacts contain 56,671 LoC (15,584 has been manually written and 41,177 are generated from the model to automatically manage model entities, model load and serialization, \dots The Figure~\ref{fig:fig3}  illustrates the configuration model of the applications using the Kevoree Web Editor~\footnote{http://editor.kevoree.org}. The Figure \ref{fig:fig4} focuses in particular on the configuration of the SPA presented in Figure~\ref{fig:fig1}. All the code for this application is available on github. We provide a companion web page \footnote{http://github.com/kevoree/CBSE16KevoreeJS} to provide the links to all the software artefacts we use in this experiment.  


\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{figures/fig1}
	\caption{An example of dashboard for sensor-based applications}
	\label{fig:fig1}
\end{figure}


\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{figures/fig2}
	\caption{An example of sensor node based on Intel Edison}
	\label{fig:fig2}
\end{figure}


Starting the sensor based application on a Chrome browser, running on top of a HP EliteBook 820 with Intel i7 processor, SSD hard drive and 16Gbytes of memory, takes 1533 ms from scratch. It takes 677ms when the components are available in the cache. The load time is mainly the time to download software modules on the npm registry server. Deploying the sensor based dashboard consists in writing a simple configuration.    

\ff{Ideally here we could have a very nice graph. Like we could make vary the scale of the problem and measure the rendering/downloading/... time. This way we could conclude a bit more strongly about the overhead of browser rendering. Another point is that the server is also not under pressure to in theory we can serve more ... not easy to quickly monitor}

\subsubsection{Qualitative evaluation  }
To discuss the strength and the limitations of KevoreeJS, we can discuss the current approach regarding the challenges that have been discussed in Section 2.   

\indent \textbf{1.} KevoreeJS provides an initial solution to automatically provision component implementation and third-party libraries. It reuses Bower dependencies model to knows components dependencies and automatically download and install new components. It reuse npm registry to provide public access to the component implementation. KevoreeJS does not provide any sandboxing mechanisms for components. As a result, a KevoreeJS component can easily crash the full reconfigurable SPA. 

\indent \textbf{2.} KevoreeJS provides a basic type system inherited from the Kevoree component to check component assembly description. It also supports a development that can use TypeScript to ensure that a component is conforms to its interface.  

\indent \textbf{3.} KevoreeJS provides an initial UI composition mechanism based on mashup. If this UI composition mechanism is sufficient for a sensor based dashboard, KevoreeJS does not provides advanced composition mechanism.  

\indent \textbf{4.} KevoreeJS provides an initial solution to ensure that only some peers can change the configuration model. However, there is currently no solution to manage some role based access rules on the configuration models. Kevoree relies on registries, which are the providers of the model characteristics. It deal with the same issue of trustability the Linux distributions providers (e.g debian's apt, arch's linux pacman...) have encountered in the past (i.e. what happened if an attacker corrupt a registry and reference a malware?).  In its current implementation, by default, Kevoree is unsecured.   

\indent \textbf{5.} Search Engine Optimization is still an open problem. We do not provide new concepts in the KevoreeJS to solve this issue.    

\indent \textbf{6.} We support client/server partitioning. 11 among 14 modules that has been developed for the motivating scenario are cross-platform Java-JavaScript components, consequently they can run on the server side or on the client side.  One of the component for doing complex event processing is generated from ThingML behavioral description. ThingML~\cite{DBLP:conf/models/FleureyMSB11} provides code generators for Java, JavaScript, and C. Consequently this component can be deployed dynamically on the Browser or within a Java or JavaScript Kevoree runtime on the server.  

\indent \textbf{7.} We take the design decision in KevoreeJS that the browser history only affect the component states. We do not use Browser history API to go back to a previous SPA configuration. 

\indent \textbf{8.} We currently do not provide any solutions for improving analytics in dynamically adaptable SPA.   

\indent \textbf{9.} Finally, the core take 20kbytes without any minification. The use of KevoreeJS does not have any real impact on the SPA performance.


